---
export interface Props {
  postSlug: string;
  initialLikes?: number;
}

const { postSlug, initialLikes = 0 } = Astro.props;
---

<div class="like-container flex items-center space-x-2">
  <button
    class="like-button flex items-center space-x-2 px-4 py-2 bg-gray-100 dark:bg-gray-700 hover:bg-red-50 dark:hover:bg-red-900/20 text-gray-700 dark:text-gray-300 hover:text-red-600 dark:hover:text-red-400 rounded-lg transition-all duration-200 border border-gray-200 dark:border-gray-600"
    data-post-slug={postSlug}
    data-liked="false"
  >
    <svg
      class="like-icon w-5 h-5"
      fill="none"
      stroke="currentColor"
      viewBox="0 0 24 24"
    >
      <path
        stroke-linecap="round"
        stroke-linejoin="round"
        stroke-width="2"
        d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"
      ></path>
    </svg>
    <span class="like-count font-medium">
      <svg class="animate-spin w-4 h-4" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </span>
  </button>
</div>

<script>
  // @ts-nocheck
  // GitHub Gist 기반 완전한 좋아요 시스템
  
  class GistLikeSystem {
    constructor() {
      this.githubToken = import.meta.env.PUBLIC_GITHUB_TOKEN;
      this.gistId = import.meta.env.PUBLIC_GIST_ID;
      this.userId = this.getUserId(); // 브라우저별 고유 ID
    }
    
    // 브라우저별 고유 ID 생성 (localStorage 기반)
    getUserId() {
      let userId = localStorage.getItem('blog-user-id');
      if (!userId) {
        userId = 'user_' + Math.random().toString(36).substr(2, 9) + '_' + Date.now();
        localStorage.setItem('blog-user-id', userId);
      }
      return userId;
    }
    
    // Gist에서 전체 데이터 가져오기
    async fetchGistData() {
      try {
        const response = await fetch(`https://api.github.com/gists/${this.gistId}`, {
          headers: {
            'Authorization': `Bearer ${this.githubToken}`,
            'Accept': 'application/vnd.github.v3+json'
          }
        });
        
        if (!response.ok) {
          throw new Error(`GitHub API 오류: ${response.status}`);
        }
        
        const gist = await response.json();
        const content = gist.files['blog-likes.json']?.content || '{}';
        return JSON.parse(content);
      } catch (error) {
        console.error('Gist 데이터 가져오기 실패:', error);
        return {};
      }
    }
    
    // Gist에 데이터 저장
    async saveGistData(data) {
      try {
        // 빈 문자열 키 제거
        const cleanData = {};
        for (const [key, value] of Object.entries(data)) {
          if (key && key.trim() !== '') {
            cleanData[key] = value;
          }
        }
        
        const response = await fetch(`https://api.github.com/gists/${this.gistId}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `Bearer ${this.githubToken}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            files: {
              'blog-likes.json': {
                content: JSON.stringify(cleanData, null, 2)
              }
            }
          })
        });
        
        if (!response.ok) {
          throw new Error(`GitHub API 저장 오류: ${response.status}`);
        }
        
        return true;
      } catch (error) {
        console.error('Gist 저장 실패:', error);
        return false;
      }
    }
    
    // 특정 포스트의 좋아요 정보 가져오기
    async getPostLikes(postSlug) {
      if (!postSlug || postSlug.trim() === '') {
        console.error('getPostLikes: 유효하지 않은 postSlug:', postSlug);
        return { count: 0, isLiked: false };
      }
      
      const data = await this.fetchGistData();
      let postData = data[postSlug];
      
      // 기존 데이터가 숫자인 경우 (이전 버전 호환성)
      if (typeof postData === 'number') {
        postData = { count: postData, users: [] };
      } else if (!postData) {
        postData = { count: 0, users: [] };
      }
      
      return {
        count: postData.count || 0,
        isLiked: postData.users ? postData.users.includes(this.userId) : false
      };
    }
    
    // 좋아요 토글
    async toggleLike(postSlug) {
      if (!postSlug || postSlug.trim() === '') {
        console.error('toggleLike: 유효하지 않은 postSlug:', postSlug);
        throw new Error('유효하지 않은 postSlug');
      }
      
      const data = await this.fetchGistData();
      
      // 기존 데이터 처리 (숫자인 경우 객체로 변환)
      let postData = data[postSlug];
      if (typeof postData === 'number') {
        postData = { count: postData, users: [] };
      } else if (!postData) {
        postData = { count: 0, users: [] };
      }
      
      const isCurrentlyLiked = postData.users && postData.users.includes(this.userId);
      
      if (isCurrentlyLiked) {
        // 좋아요 취소
        postData.count = Math.max(0, postData.count - 1);
        postData.users = postData.users.filter(id => id !== this.userId);
      } else {
        // 좋아요 추가
        postData.count = postData.count + 1;
        if (!postData.users) postData.users = [];
        postData.users.push(this.userId);
      }
      
      // 데이터 업데이트
      data[postSlug] = postData;
      
      // Gist에 저장
      const success = await this.saveGistData(data);
      
      if (success) {
        return {
          count: postData.count,
          isLiked: !isCurrentlyLiked
        };
      } else {
        throw new Error('좋아요 저장 실패');
      }
    }
  }
  
  const likeSystem = new GistLikeSystem();
  
  // 버튼 초기화
  async function initializeLikeButtons() {
    const buttons = document.querySelectorAll('.like-button');
    
    for (const button of buttons) {
      const postSlug = button.getAttribute('data-post-slug');
      
      // 빈 문자열이나 null 체크
      if (!postSlug || postSlug.trim() === '') {
        console.error('초기화 시 유효하지 않은 postSlug:', postSlug, 'URL:', window.location.href);
        updateButtonUI(button, 0, false);
        continue;
      }
      
      console.log('초기화 중인 postSlug:', postSlug);
      
      try {
        // Gist에서 현재 상태 가져오기
        const { count, isLiked } = await likeSystem.getPostLikes(postSlug);
        
        // UI 업데이트
        updateButtonUI(button, count, isLiked);
        
        // 클릭 이벤트 추가
        button.addEventListener('click', () => handleLikeClick(button, postSlug));
        
      } catch (error) {
        console.error(`${postSlug} 초기화 실패:`, error);
        // 에러 시 기본값 사용
        updateButtonUI(button, 0, false);
        button.addEventListener('click', () => handleLikeClick(button, postSlug));
      }
    }
  }
  
  // 좋아요 클릭 처리
  async function handleLikeClick(button, postSlug) {
    // postSlug 유효성 검사
    if (!postSlug || postSlug.trim() === '') {
      console.error('클릭 시 유효하지 않은 postSlug:', postSlug);
      return;
    }
    
    // 버튼 비활성화
    button.disabled = true;
    
    // 로딩 상태 표시
    const originalHTML = button.innerHTML;
    button.innerHTML = `
      <svg class="animate-spin w-5 h-5" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
      <span class="ml-2">Processing...</span>
    `;
    
    try {
      // 좋아요 토글
      const { count, isLiked } = await likeSystem.toggleLike(postSlug);
      
      // UI 업데이트
      updateButtonUI(button, count, isLiked);
      
      // 애니메이션 효과
      if (isLiked) {
        showHeartAnimation(button);
      }
      
    } catch (error) {
      console.error('좋아요 처리 실패:', error);
      
      // 에러 시 원래 상태로 복원
      button.innerHTML = originalHTML;
      
    } finally {
      // 버튼 다시 활성화
      button.disabled = false;
    }
  }
  
  // 버튼 UI 업데이트
  function updateButtonUI(button, count, isLiked) {
    try {
      button.setAttribute('data-liked', isLiked.toString());
      
      // 부드러운 전환을 위한 페이드 효과
      button.style.opacity = '0.7';
      
      setTimeout(() => {
        // 버튼 내용 업데이트
        button.innerHTML = `
          <svg class="like-icon w-5 h-5 transition-all duration-200" fill="${isLiked ? 'currentColor' : 'none'}" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4.318 6.318a4.5 4.5 0 000 6.364L12 20.364l7.682-7.682a4.5 4.5 0 00-6.364-6.364L12 7.636l-1.318-1.318a4.5 4.5 0 00-6.364 0z"></path>
          </svg>
          <span class="like-count font-medium transition-all duration-200">${count}</span>
        `;
        
        // 스타일 업데이트
        if (isLiked) {
          button.classList.remove('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
          button.classList.add('bg-red-50', 'dark:bg-red-900/20', 'text-red-600', 'dark:text-red-400');
        } else {
          button.classList.remove('bg-red-50', 'dark:bg-red-900/20', 'text-red-600', 'dark:text-red-400');
          button.classList.add('bg-gray-100', 'dark:bg-gray-700', 'text-gray-700', 'dark:text-gray-300');
        }
        
        // 페이드 인
        button.style.opacity = '1';
      }, 100);
      
    } catch (error) {
      console.error('UI 업데이트 실패:', error);
    }
  }
  
  // 하트 애니메이션
  function showHeartAnimation(button) {
    button.classList.add('animate-pulse');
    setTimeout(() => button.classList.remove('animate-pulse'), 600);
    
    const heart = document.createElement('div');
    heart.innerHTML = '❤️';
    heart.style.cssText = `
      position: absolute;
      left: 50%;
      top: -10px;
      transform: translateX(-50%);
      z-index: 1000;
      font-size: 18px;
      pointer-events: none;
      animation: heartFloat 1s ease-out forwards;
    `;
    
    // CSS 애니메이션 추가
    if (!document.querySelector('#heart-style')) {
      const style = document.createElement('style');
      style.id = 'heart-style';
      style.textContent = `
        @keyframes heartFloat {
          0% { opacity: 1; transform: translateX(-50%) translateY(0px) scale(1); }
          50% { transform: translateX(-50%) translateY(-10px) scale(1.2); }
          100% { opacity: 0; transform: translateX(-50%) translateY(-20px) scale(0.8); }
        }
      `;
      document.head.appendChild(style);
    }
    
    button.style.position = 'relative';
    button.appendChild(heart);
    
    setTimeout(() => {
      if (heart.parentNode) heart.parentNode.removeChild(heart);
    }, 1000);
  }
  
  // 초기화 - 더 빠른 실행
  function startInitialization() {
    // 즉시 실행
    initializeLikeButtons();
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', startInitialization);
  } else {
    // 페이지가 이미 로드된 경우 즉시 실행
    startInitialization();
  }
</script>